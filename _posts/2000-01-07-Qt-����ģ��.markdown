---
layout: post
title: "Qt-对象模型" 
comments: true
share: true
tags: Qt
---


GUI 界面需要同时具有运行时的效率以及更高级别的灵活性。为了解决这一问题，Qt “扩展”了标准 C++。所谓“扩展”，实际是在使用标准 C++ 编译器编译 Qt 源程序之前，Qt 先使用一个叫做 moc（Meta Object Compiler，元对象编译器）的工具，先对 Qt 源代码进行一次预处理（注意，这个预处理与标准 C++ 的预处理有所不同。Qt 的 moc 预处理发生在标准 C++ 预处理器工作之前，并且 Qt 的 moc 预处理不是递归的。），生成标准 C++ 源代码，然后再使用标准 C++ 编译器进行编译。

如信号函数是不需要编写实现代码的，那怎么可以通过标准 C++ 的编译呢？），这其实就是 moc 进行了处理之后的效果。


Qt 使用 moc，为标准 C++ 增加了一些特性：

- 信号槽机制，用于解决对象之间的通讯，可以认为是 Qt 最明显的特性之一；

- 可查询，并且可设计的对象属性；

- 强大的事件机制以及事件过滤器；

- 基于上下文的字符串翻译机制（国际化），也就是 tr() 函数，我们简单地介绍过；

- 复杂的定时器实现，用于在事件驱动的 GUI 中嵌入能够精确控制的任务集成；

- 层次化的可查询的对象树，提供一种自然的方式管理对象关系。

- 智能指针（QPointer），在对象析构之后自动设为 0，防止野指针；

- 能够跨越库边界的动态转换机制。


通过继承QObject类，我们可以很方便地获得这些特性。

moc 其实实现的是一个叫做元对象系统（meta-object system）的机制。使得标准 C++ 更适合于进行 GUI 编程。

QObject是以对象树的形式组织起来的。当你创建一个QObject对象时，会看到QObject的构造函数接收一个QObject指针作为参数，这个参数就是 parent，也就是父对象指针。这相当于，在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！）这种机制在 GUI 程序设计中相当有用。例如，一个按钮有一个QShortcut（快捷键）对象作为其子对象。当我们删除按钮的时候，这个快捷键理应被删除。

QWidget是能够在屏幕上显示的一切组件的父类。QWidget继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。

Qt 引入对象树的概念，在一定程度上解决了内存问题。

当一个QObject对象在**堆**上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。****这意味着，销毁这些对象的顺序也是未定义的。****Qt 保证的是，任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。Qt 保证没有QObject会被 delete 两次，这是**由析构顺序决定的**。

如果QObject在**栈**上创建，Qt 保持同样的行为。正常情况下，这也不会发生什么问题。来看下下面的代码片段：

	{
	    QWidget window;
	    QPushButton quit("Quit", &window);
	}

作为父组件的 window 和作为子组件的 quit 都是QObject的子类（事实上，它们都是QWidget的子类，而QWidget是QObject的子类）。这段代码是正确的，quit 的析构函数不会被调用两次，因为标准 C++ （ISO/IEC 14882:2003）要求，**局部对象的析构顺序应该按照其创建顺序的相反过程。**因此，这段代码在超出作用域时，会先调用 quit 的析构函数，将其从父对象 window 的子对象列表中删除，然后才会再调用 window 的析构函数。


但是，如果我们使用下面的代码：

	{
	    QPushButton quit("Quit");
	    QWidget window;
	
	    quit.setParent(&window);
	}

我们看到，在上面的代码中，作为父对象的 window 会首先被析构，因为它是最后一个创建的对象。在析构过程中，它会调用子对象列表中每一个对象的析构函数，也就是说， quit 此时就被析构了。然后，代码继续执行，在 window 析构之后，quit 也会被析构，因为 quit 也是一个局部变量，在超出作用域的时候当然也需要析构。但是，这时候已经是第二次调用 quit 的析构函数了，C++ 不允许调用两次析构函数，因此，程序崩溃了。

由此我们看到，Qt 的对象树机制虽然帮助我们在一定程度上解决了内存问题，但是也引入了一些值得注意的事情。所以，我们最好从开始就养成良好习惯，在 Qt 中，**尽量在构造的时候就指定 parent 对象，并且大胆在堆上创建。**

在 main() 函数中，不应该在堆上面创建对象。这是由于如果在 main() 中在堆上面创建对象，app.exec() 函数是一个死循环，创建出的这个对象没有办法被 delete。

另外的原因是，由于我们的 QApplication 是在栈上面创建的，在堆上面创建的 QLabel 对象生命周期要长于 QApplication，这在 Qt 中是应该避免的。而对于我们自己定义的组件就没有这个问题，因为不在 main() 函数中，我们始终可以保证最晚在关闭时销毁（当然是不发生内存泄露的情况下），也就没有这个问题。

使用 new 创建的对象全部是在堆上面创建的，不使用 new 的都是在栈上创建的。

